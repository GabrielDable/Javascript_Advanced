/*


1. Execution Context and Memory Storage.

One a function is called, one create a live store of data in local memory for that function execution context.
One the execution is finished, every thing is deleted, except the returned value. 
The execution context is stored in the local memory, and the data of the execution is never persistent.

    1.1 Returning a nested function definitin */ 


    function generator () {
        function nested (x) { 
            return x * 2
        }
        return nested // Return a Function definition only
    }

    const genereted = generator() //  Generator() execution will return the nested function definition. 

    /* The function will persist in memory stored in the global memory as a Constant Generated.


    1.2 Returning the value from a nested function execution

    The same codea aboce, addind parethesis to  return nested()
    The execution of the generator() will return x * 2 rather than the nested definition.


    1.3 Calling a function in the same scope as it was defined. */ 
    
    function outer() {
        let counter = 0;
        function increment () {
            counter++
        }
         return increment
    }

    /*

    Counter Variable and Increment Function are declared in the local memory, in the same execution context.
    The function increment access the counter declaration in outer scope (CLOSURE).


    Lets return the increment function definition to the global context. What happens to the closure ?

    Probably the execution of increment function in the global memory will break as it was defined as an inner function accessing values of the outer scope. */

    persist = outer()

    console.log(persist())







    // Why not just declaring the nested function in global scope directly ? 











/*

 - Closures
a) Like most of the programming languanges, javascript uses lexical scoping. 
b) The Lexical Scoping Rule: Functions are executed using the variables scope where they were originally defined, not the varible scope they are invoked. (closure)
c) Most of the time, functions are invoked in the same scope they were defined.

Closures become interesting when a function is invoked in differente scope whichone they were originally defined.
This happens when a nested function object is returned from the function whitin which it was defined.

Wrapping up: Closures Capture the local variable (and parameter) bindings of the
outer function within which they are defined.

Example 

Nested Function Statement */

let i = "global scope"

function x () {
    let i = "local scope"
    function nested () { // neted () was defined in the same scope of I, acessed from the inner function scope.
        console.log(i)
    }
    return nested()
}


x() // Local Scope


// Nested Arrow Function Statement

function p () {
    let i = "local scope";
    nested = () =>  console.log(i)
    return nested()
    
}

p()  // Local Scope


// The Scope Chain

function pp () {
    nested = () =>  console.log(i)
    return nested()
}

function pp() // Global Scope - The nested function can acess the outerscope, once there is no shadowing local variable


// Acessing the nested function directly from the global scope.


function t () {
    let i = "local scope";
    function f() { return i; }
    return f // Must return the object rather than invokation. 
} 

console.log(t()()) // Local Scope


// Imediately Invoked Function  with a nested function

let imediate = (function () {
    counter++;
    return function p () { return counter++};
    
} () ) // can assign the nested function to be returned at the same time of the declaration, as it will be immediately invoked. 

console.log(counter++)

// Variables declaration within functions scopes in two different invokations context

function counter() {
    let n = 0;
    return {
        count: function() { return n++; },
        reset: function() { n = 0; }
    };
}

let c = counter(), d = counter () // C and D will recevei the two functions nested as methods of an object.

     
    console.log(c.count()) // 0
    console.log(c.count()) // 1 - Despite C not receiving the n variable declaration, both methods still refers to the lexical scope they were originally difined, acessingthe outer scope

    d.reset() // assing n = 0
    console.log(c.count()) // 2 - d-reset method will change n value in the scope generated by d() invokation.
    console.log(c)  // { count: [Function: count], reset: [Function: reset] } , despite not explicit, there is n variable for each c and d scope

/* Wrapping Up

Those two invocation of counter() created two identfical objects, each one passed to C and D Variable.
Each object returned has two methods (closures), refering to the same private variable from the outescope.
Although, each variable C and D will interact indepedently with the private variable, as each invocation of Counter() created differente scopes.

A private variable might interact with inner closures. But the same priva variable can be redeclared in different scopes, being, therefore different variables.

 - Scopes and Interations in a loop */ 

 function interator() {
     arra =[]
     for( var i = 0; i>10; i++) {
        arra[i] = () => i
     }
 }

 arro = interator()
 console.log(arro)



// Versioning a function Execution. Passing versions to a dataset object

function outer() {
    let counter = 0;
    let dataset_outer = new Object
    let j = 0
    function incremento (x) {
        counter += x
        dataset_outer[`V.${j++}`] = counter
        return dataset_outer       
    }
     return incremento  

}


meimoze = outer()
console.log(meimoze(2))
console.log(meimoze(5)) 
console.log(meimoze(15)) //{ 'V. 0': 2, 'V. 1': 7, 'V. 2': 22 }

 

 
